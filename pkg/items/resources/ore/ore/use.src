//////////////////////////////////////////////////////////////////
// This is a general script for items which can be transformed  //
// by using them with a forge. The variable name "ore" is used  //
// to represent any item which will be used on a forge.         //
//////////////////////////////////////////////////////////////////
use uo;
use os;
use cliloc;

include "include/client";
include "include/objtype";
include "include/canAccess";
include ":attributes:attributes";

var itemdescs := ReadConfigFile(":*:itemdesc");

program smelt_that_ore (who, ore)

	// If meditating stop meditation.
	EraseObjProperty(who, "IsMeditating");
	SendSysMessageCL(who, 500134, {}, 3, 33); // You stop meditating.
	// If healing with bandages, stop healing.
	EraseObjProperty(who, "HealTimer");
	if(!can_access(who, ore))
		return;
	endif
	if(ore.movable == 0)
		SendSysMessageCL(who, 501973, {}, 3, 33); // You cannot use that.
		return;
	endif
	// Get the info from itemdesc files for the "ore" being used
	SmeltOre(who, ore, CInt(itemdescs[ore.objtype].Product),  CDbl(itemdescs[ore.objtype].Difficulty));
endprogram
function SmeltOre(who, ore, ingot, difficulty)
	if(!ReserveItem(ore))
		return;
	endif
	if(!Accessible(who, ore))
		SendSysMessageCL(who, 501975, {}, 3, 33); // That is too far away.
		return;
	endif
	var forge := TargetCoordinates(who);
	var dist := CoordinateDistance(who.x, who.y, forge.x, forge.y);
	// If there is a dynamic item at the location TargetCoordinates() returns the item reference
	// and we make the variable "forge" equal to that.
	// I have to admit eScript's weak variable typing simplifies this and I took advantage of this :P
	if(forge.item)
		forge := forge.item;
	endif
	// If there was no item reference then we are still OK because if there was a static item at the location
	// TargetCoordinates() gives the ObjType number of that static item.
	// So we check to see if the ObjType of either the dynamic item or static item matches the ObjTypes of known forges.
	if((forge.objtype == 0xfb1) || forge.objtype == 0x2DD8|| ((forge.objtype >= CInt(0x197a)) && (forge.objtype <= CInt(0x19a9))))
		// We have to check Line Of Sight (LOS) to the targetted location because TargetCoordinates() has no
		// flags for LOS check as does Target().
		if(!CheckLosBetween( who.x, who.y, who.z, forge.x, forge.y, forge.z, who.realm ))
			SendSysMessageCL(who,500876, {}, 3, 33); // You can't see that.
			return;
		endif
		// If the distance between the player and the forge is greater than 2 squares
		// send the cliloc message "That is too far away." in font 3 colour red.
		// The empty array in SendSysMessageCL is necessary because some cliloc
		// messages can have text inserted in them. See the cliloc.em documentation
		// for more information.
		if(dist > 2)
		SendSysMessageCL(who, 501975, {}, 3, 33); // That is too far away.
			return;
		endif
		if(Distance(who, ore) > 2)
			SendSysMessageCL(who, 501976, {}, 3, 33); // The ore is too far away.
			return;
		endif
		if(SkillCheck(who, MINING, CDbl(difficulty), 10) > 0)
			PlaySoundEffect(forge, 0x2C);
			sleep(2);
			var ingots := CreateItemInBackpack(who, ingot, (GetAmount(ore) / 2));
			ReserveItem(ingots);
			if(ingots)
				if(DestroyItem(ore))
					SendSysMessageCL(who,50198, {}, 3, 66); // You smelt the ore removing the impurities and put the metal in your backpack.
					return;
				else
					CreateItemAtLocation(who.x, who.y, who.z, ingot, (GetAmount(ore) * 2), who.realm);
					SendSysMessage(who, 1008122, 3, 33); // Your backpack is too full to put the material into.
					return;
				endif
			endif
		else
			SubtractAmount(ore, 1);
			SendSysMessageCL(who, 501989, {}, 3, 33); // You burn away the impurities but are left with no useable metal.
			return;
		endif
	else
		SendSysMessage(who, "That is not a forge.");
	endif
endfunction
